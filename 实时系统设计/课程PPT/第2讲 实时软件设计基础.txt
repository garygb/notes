----------------------- Page 1-----------------------


----------------------- Page 2-----------------------

                 目录  
                 

        2.1  生命周期问题  
        2.2  软件设计概念  
        2.3  信息隐藏  
        2.4  面向对象  
        2.5  有限状态机  

2018/11/16                                            2  

----------------------- Page 3-----------------------

2.1  生命周期问题  
  

    与任何软件系统一样，在开发并发与实时系统时，也 

  应该使用软件生命周期模型，这是分阶段开发软件的方法 
  瀑布模型是使用最为广泛的软件生命周期模型。这部分将 
  对瀑布模型进行概述。另外还会介绍其他一些软件生命周 
  期模型。  

   

 2018/11/16                                        3  

----------------------- Page 4-----------------------

   2.1  生命周期问题  
  
  2.1.1  瀑布生命周期模型  

1.需求分析和规范  
     使用瀑布模型的阶段，必须确认并分析用户的需求。用户的需 
    求包括软件需求和系统需求。实时系统通常是较大的嵌入式系统 
    的组成部分，所以确定系统需求分析和规范阶段的工作就很有可 
    能要在确定软件需求分析和规划工作之前进行。  

2.构架设计  
      在模型阶段中,系统从结构上分解为各个组成部分。并发实时 
    系统与其他系统区分开的重要因素一个是这种系统将自身分解为 
    多个并发任务，另一个是对系统在行为方面的考虑。  

3.详细设计  
      在详细设计阶段，要使用程序设计语言表示法定义系统各个 
    组成部分。在并发与实时系统中要注意资源共享的算法，要避免 
    出现死锁情况，还要注意与硬件I/O设备的接口。     

2018/11/16                                   4  

----------------------- Page 5-----------------------

 4.编码  
      遵照编写代码和文档的标准，使用项目中所选择的编程语 
  言来编写各个组成部分的代码。对于并发系统来说，要选择 
  使用并发语言(Ada,Modula2)，或者选择多任务操作系统或内 
  核所支持的序列化语言。  

 5.软件测试  
       并发与实时系统包含了多个并发任务，或者与多个外部 
  设备之间存接口。系统的执行具有不确定性，而且实时系统 
  通常是嵌入式系统，所以测试更为复杂。有时需要开发环境 
  模拟器。需要分几个阶段对软件系统测试。单元测试和集成 
  测试都是“白盒”测试方法，需要了解软件内部结构，系统 
  测试是一种“黑盒”测试方法，要依照软件需求规范。  
      

   

2018/11/16                                      5  

----------------------- Page 6-----------------------

6.单元测试  
         单元测试由在与其他组成部分结合之前，对单个组成部分进行 
  的测试组成。最低覆盖原则每条语句只要执行一次，每个输出分 
  支至少测试一次。  

7.集成测试  
     集成测试是将经过测试的组成部分逐渐结合为一些更加复杂的 
  组成部分，并且在将整个软件系统组合在一起并对接口进行测试 
  之后，对这些分组进行测试。并发系统集成测试的特点是需要对 
  并发任务接口进行测试。  

8.系统测试  
        系统测试是对集成后的硬件和软件系统进行测试的过程，以确 
  保系统符合需求规范。需要对并发和/或实时系统的某些方面进行 
  测试。包括：功能测试、负载(压力)测试、性能测试  

9.验收测试  
       验收测试通常由用户组织或其代表来实施。  

 2018/11/16                                        6  
  

----------------------- Page 7-----------------------

2.1  生命周期问题  
 2.1.2  其他软件生命周期模型  

1.抛弃式原型法  
     抛弃式原型是一种开发快速,成本低廉的工作系统,用于帮 
  助澄清用户的需求。在初步需求规范之后就可以开发抛弃式原 
  型。通过让用户在原型上练习操作，可以得到很多有价值的反 
  馈信息。根据这些反馈信息，可以完成一份经过修订的需求规 
  范。随后的开发过程遵照常规的软件生命周期模型继续进行。  

2.增量式开发的演化原型法  
     演化原型法是一种增量式开发的形式，其中的原型要经过 
  几个过渡的运行系统演化为可交付系统。通过在较长时间段内 
  展开实施过程，对于测试设计的关键组成部分和降低开发风险 
  来说，这种方法有助于确定系统是否满足了性能上的需求。    

2018/11/16                                 7  

----------------------- Page 8-----------------------

   
 3.螺旋模型  
      螺旋模型是一种迭代生命周期模型,其中的每一次螺 
   旋循环都代表一次迭代.径向坐标代表累积开销.每次迭 
   代的一个重要方面就是项目的风险评估.要识别出具有 
   最大不确定性的区域和潜在的重要问题.只有在风险减 
   少到管理层可以接受的水平时,才可以开始进行具体的 
   实施工作。  

2018/11/16                                      8  

----------------------- Page 9-----------------------

2.2  软件设计概念  

          本节介绍的是并发与实时系统软件设计的关键概念。 
  我们会对前面介绍的并发处理概念进行深入探讨，尤其是 
  并发任务之间的通信与同步问题。  
             随后会介绍系统环境以及支持并发处理的操作系统。 
 信息隐藏的概念要从系统分解为多个模块的角度来介绍。 
  面向对象的概念要与面向对象设计中信息隐藏的作用一同 
 讨论，此外还引入了类和继承的概念，最后要介绍的是并 
  发与实时系统设计中有限状态机的作用。  

 2018/11/16                                 9  

----------------------- Page 10-----------------------

2.2  软件设计概念  
 2.2.1  并发处理  

  并发任务的通信与同步：  
     在大多数实时和并发应用程序中，并发任务必须相 
  互协作，以执行供应用程序所要求的服务。当各个任务 
  之间相互协作时,会出现以下三个常见问题：  
   1)互斥问题  
      当任务需要对某种资源(如共享数据或物理设备)具 
  有独占的访问权时，就会发生这种错误。  
      为了解决这种问题，必须提供一种同步机制，以保 
  证多个任务对关键资源的访问是互斥的。其经典解决方 
  案最早是由Dijkstra使用二元信号量提出的。二元信号 
  量s是一个布尔变量，仅能使用两个原子操作P操作 
  (Wait(s))和V操作(Signal(s))。  
     这个问题的另一种形式是多读者/多写者问题。  
2018/11/16                                10  

----------------------- Page 11-----------------------

  2)任务同步问题  
     当两个任务需要协同运行，但不在任务之间传递数 
  据时，使用事件同步。事件用于同步两个任务的运行。 
  源任务执行一个Signal （事件）操作，它发出信号，说 
  明一个事件已经发生。目标任务执行一个Ｗait （事件） 
  操作，将任务挂起，直到事件接收到来自信号生成者的 
  信号为止。如果事件已经接收到了信号，那么目标任务 
  就不再处于挂起状态。  
    

2018/11/16                                   11  

----------------------- Page 12-----------------------

   3)生产者/消费者问题  

     在并发系统中，每个任务都有自己的控制线程，各 
  个任务之间采用异步方式执行。因此，当各个任务之间 
  需要交换数据时，就要对任务的运行进行同步。数据必 
  须要在消费者使用之前由生产者生成出来。如果消费者 
  已经为接收数据做好准备，但生产者还没有生成数据， 
  那么消费者就必须等待生产者。如果生产者在消费者为 
  接收数据做好准备前就已经生成了数据，那么生产者就 
  不得不停下来，或者缓冲传递给消费者的数据，这样才 
  能继续生成数据。  
        

2018/11/16                                   12  

----------------------- Page 13-----------------------

2.2  软件设计概念  

  2.2.2 并发处理的环境  
  并发系统三种主要环境：  

   1)多道程序环境  
         多个任务共享一个处理器。 
   虚拟的并发通过让操作系统 
   为各个任务控制处理器的分 
   配来实现的，看起来好象每 
   个任务都有一个专用的处理 
   器。  图2.1演示了用于小型机 
   或者微机的典型多道程序环 
   境。在图2.1 中有一个CPU卡 
   和内存卡用于存储任务和数 
   据，使用设备接口卡连接了            图2.1多道程序(单CPU)环境  
   两个I/O设备，显示设备和传 
   感器输入设备。   
                2018/11/16   13  

----------------------- Page 14-----------------------

   2)多处理器环境  
     如图2.2在这种环境 
  中有两个或两个以上的 
  处理器使用共享内存。 
  所有处理器都有一个公 
  用的虚拟地址空间。所 
  有任务都驻留在共享内 
  存中。在多处理器环境 
  中，当多个处理器并发 
  执行时，所实现的就是                图2.2 多处理器环境  
  真实的并发。  
  
  

               2018/11/16    14  

----------------------- Page 15-----------------------

    3)分布式处理环境  
     在这种环境中，有两 
  台或多台计算机通过通信 
  网络或高速总线相互连接。 
 每台计算机都有自己的本 
 地内存，在处理器之间没 
 有共享内存。因此，由多 
 个并发任务组成的分布式 
 应用程序可以使分布在网 
 络上的任务通过消息进行 
 通信。图2.3中的结点通常 
 都由前述图2.1所示的多道 
 程序系统或图2.2所示的多           图2.3 分布式处理环境  
 处理器系统。  

              2018/11/16  15  

----------------------- Page 16-----------------------

2.2  软件设计概念  

 2.2.3  并发处理的操作系统支持  

   1)运行时支持服务  
      通过使用一条实时多任务指令(也称为操作系统内核)或 
  执行并发语言的运行时支持系统,就可以提供并发任务的运行 
  时支持。  
     如果要使用序列化语言开发并发任务应用程序，就必须使 
  用多任务内核。多任务内核所提供的典型服务：  
      (1)抢占式优先级调度  
      (2)使用消息进行任务间通信  
      (3)使用信号量进行互斥访问  
      (4)使用事件来实现任务间同步  
      (5)中断处理和基本的I/0服务  
      (6)内存管理  
      而并发语言提供了可以支持任务通信和同步的构造。  

2018/11/16                                   16  

----------------------- Page 17-----------------------

  

 2)任务调度  
     在单处理器系统中，多任务内核必须为CPU调度并发任 
  务。内核为所有任务准备好使用CPU的Ready List。对于分 
  时共享系统多个用户要交互式地访问系统，经常使用轮询 
  调度算法。对于实时系统更为合适的算法是抢占式优先级 
  调度算法。  
     在多处理器环境中，会有一个多任务内核的副本在每个 
  处理器上执行。每个处理器都会选择执行Ready List中最 
  上面的任务。对Ready List的互斥访问是使用硬件信号量 
  来实现的。      
  

2018/11/16                                              17  

----------------------- Page 18-----------------------

  3)输入/输出问题  
      实现输入/输出有两种通用机制，中断驱动I/O和轮询 
   I/O。  
    使用中断驱动I/O时，当接受到输入数据或者完成一次输出 
     操作之后就会产生一次中断。使用这种机制有两种常用方法， 
     一种方法时是在读写每个字符之后产生中断。另一种方法是 
     在I/O设备和主存之间放置一个DMA设备。  
    在使用轮询I/O机制时，系统必须定期对输入设备进行取样， 
      以确定是否有任何输入已经到达，并定期对输出设备进行采 
     样，以确定输出操作是否已经完成。  

  

2018/11/16                                      18  

----------------------- Page 19-----------------------

2.3  信息隐藏  

      信息隐藏是一种基本的软件设计概念。使用信息隐藏 
  把可能发生变化的信息封装在一个模块的内部。对信息的 
  外部访问只能通过间接调用也属于模块一部分的操作，这 
  样隐藏信息和访问信息的操作放在一起就形成了信息隐藏 
  模块。  

        

 2018/11/16                                            19  

----------------------- Page 20-----------------------

2.3  信息隐藏  

2.3.1 应用于内部数据结构的信息隐藏  

      信息隐藏可用于隐藏与数据结构，其内部联系以及操作 
 数据结构的操作细节相关的设计决策。其他的模块只能通过 
 调用模块的间接操作来访问封装后的的数据结构。这样对某 
 个模块的修改只要其外部接口没有发生改变，间接访问其数 
 据结构的其他模块就不用改变。  

2018/11/16                                   20  

----------------------- Page 21-----------------------

2.3  信息隐藏  

 2.3.2  应用于访问同步的信息隐藏  
   

        解决互斥问题和多读者/多写者问题的方案容易发生错 
  误。可能会在访问共享数据的一个任务中出现编码错误， 
  这样会在执行时产生严重的同步错误。这些潜在的问题都 
  是由同步全局的问题引起的，而使用信息隐藏的方法，全 
  局同步问题就可以简化为本地同步问题，只需要在同步过 
  程中考虑一个信息隐藏模块即可。  

  

 2018/11/16                                       21  

----------------------- Page 22-----------------------

2.3  信息隐藏  

 2.3.3  应用于I/O设备的信息隐藏  

      信息隐藏可以用于隐藏如何与具体I/O设备接口的设计 

  决策。  

      解决方案是向隐藏设备具体细节的设备提供一个虚拟接 
   口。如果该设备由另一个具有相同功能的设备替换，需要 

  修改模块的内部操作，因为它们必须处理如何与真实设备 

  接口的精细细节。然而由操作规范代表的虚拟接口保持不 

  便，访问设备接口的模块也无需修改。  

    

 2018/11/16                                  22  

----------------------- Page 23-----------------------

2.4  面向对象  

       Wegner把支持对象(信息隐藏模块)但不支持继 
  承的语言(Ada,Modula-2)称为基于对象的语言； 
  把既支持类又支持对象的语言(CLu)称为基于类的 
  语言；而把支持对象，类和继承的语言 
   (Smalltalk,C++,Eiffel)称为面向对象的语言  

   

 2018/11/16                                             23  

----------------------- Page 24-----------------------

2.4  面向对象  

 2.4.1  主动对象和被动对象  

           对象可以是主动的，也可以是被动的。主动对象也就是 

   自治的异步对象，可以启动自己的操作。主动对象是并发 

   任务，有自己的控制线程，可以独立于其他任务执行。被 

   动对象是一种信息隐藏模块，没有控制线程，其操作由主 

   动对象来调用。本讲所提到的对象一般都指被动对象。  

 2018/11/16                                    24  

----------------------- Page 25-----------------------

2.4  面向对象  

 2.4.2  类  

         类是一种对象类型，是用于对象的模板。类的概念通 
   常要与抽象数据类型联系在一起。类一般定义为抽象数据 
   类型的实现。对象是信息隐藏模块，则类是一种模块类型。  

2018/11/16                                          25  

----------------------- Page 26-----------------------

2.4  面向对象  

 2.4.3  继承  

      可以使用继承对类进行限定。继承是用于在类之间共 
   享和重用代码的一种机制。通过添加新的操作和实例变量， 
   或者对现有的操作重新进行定义，一个子类可以使用其父 
   类的结构(即封状的数据)和行为(即操作)，用于自己使用。  

     

 2018/11/16                                                 26  

----------------------- Page 27-----------------------

类和继承 – wikipedia, Baidu   

                 湖南大学信息科学与工程学院  安吉尧  
                                                                         27  

----------------------- Page 28-----------------------

2.5  有限状态机  

          有限状态机可以用于为系统的行为方面进行建模。许 
  多实时系统都非常依赖于状态，亦即它们的操作不仅依赖 
  于输出信息，而且还依赖于以前发生过的情况。可以使用 
  一个有限状态机来定义实时系统的状态依赖方面。  

      有限状态机是一种概念上的机器，具有一定数量的状 
  态。在某个特定时刻只能处于其中一种状态，状态转换是 
  由输入事件引起的状态变化，理论上是不占用时间的，实 
  际上发生状态转换的时间可以忽略不计。  

      用于定义有限状态机的表示法是状态转换图和状态转 
  换表或矩阵。  

2018/11/16                               28  

----------------------- Page 29-----------------------

2.5  有限状态机  
 2.5.1  有限状态机在实时系统设计中的使用  

     大规模的系统都非常依赖于状态，状态转换图或表格/ 
   矩阵对理解系统复杂性很有帮助。使用有限状态机对系统 
   进行建模时，状态和转换是有限的，状态表示系统行为的 
   模式。系统在某一时刻只能处于一种状态，所以一种状态 
   代表的系统中当前发生的情况。  

      复杂系统的状态转换图也可能是复杂的，简化系统有 
   限状态机表示的方法就是使用单独的状态转换图对系统的 
   不同方面进行建模。       

 2018/11/16                               29  

----------------------- Page 30-----------------------

  2.5  有限状态机  
   2.5.2  状态转换图的例子  

              将并发任务的不同状态作为状态转换图的例子来研究。这些 
   状态有一个多任务内核来维持，这个内核用的是抢占式优先级调度 
   算法。任务的不同状态可以在一个状态转换图上描述，状态用方框 
   表示，转换用折线表示。  
     当首次创建任务时，它处 
  于就绪状态，这时它位于就绪 
  列表中。当该任务到达就绪列 
 表的顶端时，就可以得到CPU 
  资源，这时它就转换到了执行 
 状态。此后该任务的资源就可 
  以被另一个任务抢占。  

                        图2.4 并发任务的状态转换图  

  2018/11/16                                30  

----------------------- Page 31-----------------------

     进入就绪状态，这时内核就会根据它的优先级将其放 
  置在就绪列表中的某个位置上。  
      当处于执行状态时，任务可能会发生阻塞，在这种情 
  况它就会进入相应的阻塞状态。  
      一个任务可能因为等待I/O，等待另一个任务发送来 
  的消息，等待计时器事件或由另一个任务激发的事件，或 
  者等待进入临界端而发生阻塞。当I/O操作完成，消息到 
  达，发生了事件，或者任务获得允许进入临界段，此时阻 
  塞的任务就重新进入就绪状态。  

2018/11/16                                31  

----------------------- Page 32-----------------------

FSM – wikipedia, Baidu   

                  湖南大学信息科学与工程学院  安吉尧  
                                                                             32  

----------------------- Page 33-----------------------

    
      本讲主要应理解实时软件设计理念及基本概念  
   
   
                          本讲结束，欢迎讨论！  

2018/11/16                                                                         33  
