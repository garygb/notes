设计模式

1. creational   --关键是考虑如何创建对象的问题（单例，工厂，抽象工厂，Builder，Prototype）
2. structural    --如果你有两个对象，你想把这两个对象组合起来放进你的对象(重点：组合)
3. Behavioural--我们不想组合多个对象，但是我们希望在这些对象之间有一些交流（重点：通信）



1. 工厂模式
       public class FactoryMain {
       
       	public static void main(String[] args) {
       		OS obj = OSFactory.getInstance("Open");
       		OS obj2 = OSFactory.getInstance("Closed");
       		obj.spec();
       		obj2.spec();
       	}
       }
       public class OSFactory {
       
       	public static OS getInstance(String str) {
       		
       		if (str.equals("Open")) {
       			return new Android();
       		} else if (str.equals("Closed")) {
       			return new IOS();
       		} else {
       			return new Windows();
       		}
       	}
       }
       public interface OS {
       	public void spec();
       }
       public class Android implements OS {
       	
       	@Override
       	public void spec() {
       		System.out.println("Most powerful OS");
       	}
       }
   
2. Builder
       // Builder Pattern - Creational Design Pattern
       public class Shop {
       
       	public static void main(String[] args) {		
       		
       //		Phone p1 = new Phone("Android", 4, "Comm", 4.5, 3000);
       		
       		// 使用PhoneBuilder
       		// 优点:可以设置这些属性 in any order,不想设置的属性可以不设
       		Phone p2 = new PhoneBuilder().setRam(2).setOs("Android").getPhone();	
       		System.out.println(p2);
       	}
       
       }
       public class PhoneBuilder {
       
       	private String os;
       	private int ram;
       	private String processor;
       	private double screenSize;
       	private int battery;
       	
       	public PhoneBuilder setOs(String os) {
       		this.os = os;
       		return this;
       	}
       	public PhoneBuilder setRam(int ram) {
       		this.ram = ram;
       		return this;
       	}
       	public PhoneBuilder setProcessor(String processor) {
       		this.processor = processor;
       		return this;
       	}
       	public PhoneBuilder setScreenSize(double screenSize) {
       		this.screenSize = screenSize;
       		return this;
       	}
       	public PhoneBuilder setBattery(int battery) {
       		this.battery = battery;
       		return this;
       	}
       	
       	public Phone getPhone() {
       		return new Phone(os, ram, processor, screenSize,battery);
       	}
       	
       }
       public class Phone {
       
       	private String os;
       	private int ram;
       	private String processor;
       	private double screenSize;
       	private int battery;
       	
       	public Phone(String os, int ram, String processor, double screenSize, int battery) {
       		super();
       		this.os = os;
       		this.ram = ram;
       		this.processor = processor;
       		this.screenSize = screenSize;
       		this.battery = battery;
       	}
       
       	@Override
       	public String toString() {
       		return "Phone [os=" + os + ", ram=" + ram + ", processor=" + processor + ", screenSize=" + screenSize
       				+ ", battery=" + battery + "]";
       	}
       	
       	public Phone setOS(String os) {
       		this.os = os;
       		return this;
       	}
       	
       }
   
3. Adapter （Structural）
       public class School {
       
       	public static void main(String[] args) {
       
       		AssignmentWork aw = new AssignmentWork();
       		aw.setPen(new PenAdapter());
       		aw.writeAssignment("I'm a bit tired to write an Assignment.");
       	}
       
       }
       public class AssignmentWork {
       	
       	private Pen p;	
       	
       	public Pen getPen() {
       		return p;
       	}
       
       	public void setPen(Pen p) {
       		this.p = p;
       	}
       
       	public void writeAssignment(String str) {
       		p.write(str);
       	}
       }
       public interface Pen {
       	void write(String s);
       }
       public class PilotPen {
       	public void mark(String str) {
       		System.out.println(str);
       	}
       }
       import com.marry.PilotPen;
       
       public class PenAdapter implements Pen {
       
       	@Override
       	public void write(String s) {
       		PilotPen pp = new PilotPen();
       		
       		pp.mark(s);
       	}
       }
   我想要一个Pen的implementation，但是我使用别人提供给我的和Pen毫无相干的类来适配，通过一个适配器类来实现将这个PilotPen类的方法交给调用Pen接口的方法。
4. Composite （Structural）
   当你在创建一个树形结构的软件的时候（一个object里面能容纳multiple objects）需要用到。
   当你可以对leaf node做的operation，你也可以对composite object做。
       public class CompositeTest {
       
       	public static void main(String[] args) {
       		Component hd = new Leaf(4000, "HardDrive");
       		Component mouse = new Leaf(4000, "Mouse");
       		Component monitor = new Leaf(4000, "Monitor");
       		Component ram = new Leaf(4000, "RAM");
       		Component cpu = new Leaf(4000, "CPU");
       		
       		Composite ph = new Composite("Peri");
       		Composite cabinet = new Composite("Cabinet");
       		Composite mb = new Composite("MB");
       		
       		Composite computer = new Composite("Computer");
       		
       		ph.addComponent(mouse);
       		ph.addComponent(monitor);
       		cabinet.addComponent(hd);
       		cabinet.addComponent(mb);
       		mb.addComponent(ram);
       		mb.addComponent(cpu);
       		
       		computer.addComponent(ph);
       		computer.addComponent(cabinet);
       		
       		ram.showPrice();
       		System.out.println();
       		ph.showPrice();
       		System.out.println();
       		computer.showPrice();
       	}
       
       }
       public interface Component {
       	void showPrice();
       }
       public class Leaf implements Component {
       
       	private int price;
       	private String name;
       	
       	public Leaf(int price, String name) {
       		super();
       		this.price = price;
       		this.name = name;
       	}
       
       	@Override
       	public void showPrice() {
       		System.out.println(name + " : " + price);
       	}
       
       }
       public class Composite implements Component {
       
       	private String name;
       	List<Component> components = new ArrayList<>();
       	
       	
       	public Composite(String name) {
       		super();
       		this.name = name;
       	}
       
       	public void addComponent(Component com) {
       		components.add(com);
       	}
       	
       	@Override
       	public void showPrice() {
       		System.out.println(name);
       		// 这里很有意思：不论是Leaf还是Composite,都是Component
       		// 如果是Leaf就直接打出价格来了
       		// 如果是Composite的话则递归
       		for (Component c : components) {
       			c.showPrice();
       		}
       	}
       
       }
   
5. Prototype 
